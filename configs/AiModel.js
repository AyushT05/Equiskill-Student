const {
  GoogleGenerativeAI,
  HarmCategory,
  HarmBlockThreshold,
} = require("@google/generative-ai");

const apiKey = process.env.NEXT_PUBLIC_GEMINI_API_KEY;
const genAI = new GoogleGenerativeAI(apiKey);

const model = genAI.getGenerativeModel({
  model: "gemini-2.0-flash",
});

const generationConfig = {
  temperature: 1,
  topP: 0.95,
  topK: 40,
  maxOutputTokens: 8192,
  responseMimeType: "application/json",
};

const generationConfig1 = {
  temperature: 1,
  topP: 0.95,
  topK: 40,
  maxOutputTokens: 8192,
  responseMimeType: "text/plain",
};

export const courseOutline = model.startChat({
  generationConfig,
  history: [
    {
      role: "user",
      parts: [
        { text: "Generate a study material for Python for an Exam and level of difficulty will be Easy with summary of course, list of Chapter along with summary for each chapter, Topic list in each chapter in  All in Json format" },
      ],
    },
    {
      role: "model",
      parts: [
        { text: "```json\n{\n  \"course_name\": \"Introduction to Python Programming\",\n  \"difficulty\": \"Easy\",\n  \"course_summary\": \"This course provides a gentle introduction to Python programming, covering fundamental concepts and syntax. It is designed for beginners with no prior programming experience, focusing on building a solid foundation for further learning. You'll learn how to write simple programs, work with data, and understand basic programming logic.\",\n  \"chapters\": [\n    {\n      \"chapter_number\": 1,\n      \"chapter_title\": \"Getting Started with Python\",\n      \"chapter_summary\": \"This chapter introduces the Python programming language, how to set up your environment, and write your first basic program. It covers the essential tools and concepts needed to begin coding.\",\n      \"topics\": [\n        \"What is Python?\",\n        \"Why learn Python?\",\n        \"Setting up the Python environment (Installation, IDE/Text Editor)\",\n        \"Writing your first Python program (Hello, World!)\",\n        \"Running Python programs\",\n          \"Understanding basic Python Syntax\"\n        \n      ]\n    },\n    {\n      \"chapter_number\": 2,\n      \"chapter_title\": \"Variables and Data Types\",\n      \"chapter_summary\": \"This chapter introduces the concept of variables, and basic data types including numbers, strings and booleans. It will allow the student to store and manipulate information in Python\",\n      \"topics\": [\n        \"What are variables?\",\n        \"Declaring and assigning variables\",\n        \"Data types: Integers (int), Floating-point numbers (float), Strings (str), Booleans (bool)\",\n        \"Basic operations on data types (+, -, *, /, %, string concatenation)\",\n        \"Type conversion (casting)\"\n      ]\n    },\n    {\n      \"chapter_number\": 3,\n      \"chapter_title\": \"Input and Output\",\n      \"chapter_summary\": \"This chapter teaches how to interact with the user, to display information on the screen and receive input from the user. This will enable the student to write interactive programs.\",\n      \"topics\": [\n        \"The `print()` function for output\",\n        \"Formatting output using f-strings\",\n        \"The `input()` function for user input\",\n        \"Working with user input strings\"\n      ]\n    },\n      {\n          \"chapter_number\": 4,\n          \"chapter_title\": \"Basic Operators and Expressions\",\n          \"chapter_summary\": \"This chapter teaches about operators like arthimetic, comparison and logical. This will enable the student to create complex expressions and perform operations based on conditions.\",\n           \"topics\":[\n               \"Arithmetic Operators (+, -, *, /, %, **, //)\",\n                \"Comparison Operators (==, !=, >, <, >=, <=)\",\n               \"Logical Operators (and, or, not)\",\n               \"Operator precedence\",\n               \"Writing expressions in Python\"\n               ]\n      },\n    {\n      \"chapter_number\": 5,\n      \"chapter_title\": \"Conditional Statements\",\n      \"chapter_summary\": \"This chapter will help you make decisions in programs, based on conditions. The students will use the `if`, `elif` and `else` keywords to control the flow of the program.\",\n      \"topics\": [\n          \"The `if` statement\",\n          \"The `if-else` statement\",\n        \"The `if-elif-else` statement\",\n        \"Nested `if` statements\",\n          \"Simple conditional logic examples\"\n      ]\n    }\n  ]\n}\n```\n" },
      ],
    },
  ],
});

export const GenerateNotesModel = model.startChat({
  generationConfig1,
  history: [
    {
      role: "user",
      parts: [
        {text: "Generate beautiful exam material for the chapters: BFS and DFS is Data Structures. Create the notes by beautifully designing it and use emojis wherever necessary. Make sure to include all topic points in the content. Also make sure to generate the content in PURE HTML FORMAT (Do not include HTMLKL,Head,Title,and Body Tag)"},
      ],
    },
    {
      role: "model",
      parts: [
        {text: "```html\n<div class=\"container\">\n\n  <header style=\"text-align: center; padding: 20px; background-color: #f0f8ff; border-radius: 10px; margin-bottom: 20px;\">\n    <h1>üå≥ BFS & DFS: Navigating the Data Structure Jungle üå≤</h1>\n    <p>Your guide to exploring graphs and trees with Breadth-First Search and Depth-First Search!</p>\n  </header>\n\n  <section style=\"margin-bottom: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 5px;\">\n    <h2>Breadth-First Search (BFS) üåä</h2>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>üîç What is BFS?</h3>\n      <p>BFS is a graph traversal algorithm that explores all the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level. Imagine it like ripples spreading outwards from a stone dropped in water.</p>\n    </div>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>‚öôÔ∏è How BFS Works:</h3>\n      <ol>\n        <li>Start at the <b>root</b> node (or any designated node).</li>\n        <li>Enqueue the root node into a <b>queue</b>. ‚ûï</li>\n        <li>While the queue is not empty:\n          <ol type=\"a\">\n            <li>Dequeue a node from the queue. ‚ûñ</li>\n            <li>Visit (process) the dequeued node. ‚úÖ</li>\n            <li>Enqueue all the <b>unvisited</b> neighbors of the dequeued node. ‚ûï</li>\n          </ol>\n        </li>\n      </ol>\n    </div>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>üîë Key Characteristics:</h3>\n      <ul>\n        <li><b>Level-order traversal:</b> Visits nodes level by level.</li>\n        <li>Uses a <b>queue</b> data structure. ‚è≥</li>\n        <li>Suitable for finding the <b>shortest path</b> in an unweighted graph. üõ£Ô∏è</li>\n      </ul>\n    </div>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>üìù Pseudocode:</h3>\n      <pre style=\"background-color: #f9f9f9; padding: 10px; border-radius: 5px;\">\n        <code>\nBFS(graph, startNode):\n  queue = new Queue()\n  visited = new Set()\n\n  queue.enqueue(startNode)\n  visited.add(startNode)\n\n  while not queue.isEmpty():\n    node = queue.dequeue()\n    process(node) // Visit the node\n\n    for neighbor in graph.neighbors(node):\n      if neighbor not in visited:\n        queue.enqueue(neighbor)\n        visited.add(neighbor)\n        </code>\n      </pre>\n    </div>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>‚è±Ô∏è Time Complexity:</h3>\n      <p><b>O(V + E)</b>, where V is the number of vertices (nodes) and E is the number of edges.</p>\n    </div>\n\n    <div>\n      <h3>‚ûï Applications:</h3>\n      <ul>\n        <li>Finding the shortest path between two nodes in an unweighted graph.</li>\n        <li>Web crawling. üï∏Ô∏è</li>\n        <li>Social network analysis. üßë‚Äçü§ù‚Äçüßë</li>\n        <li>GPS Navigation systems. üó∫Ô∏è</li>\n      </ul>\n    </div>\n  </section>\n\n  <section style=\"margin-bottom: 30px; padding: 20px; border: 1px solid #ddd; border-radius: 5px;\">\n    <h2>Depth-First Search (DFS) ‚õ∞Ô∏è</h2>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>üîç What is DFS?</h3>\n      <p>DFS is a graph traversal algorithm that explores as far as possible along each branch before backtracking. Think of it as going down one path completely before trying another.</p>\n    </div>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>‚öôÔ∏è How DFS Works:</h3>\n      <p>DFS can be implemented recursively or iteratively (using a stack).</p>\n      <h4>Recursive Implementation:</h4>\n      <ol>\n        <li>Start at the <b>root</b> node (or any designated node).</li>\n        <li>Mark the current node as <b>visited</b>. ‚úÖ</li>\n        <li>For each <b>unvisited</b> neighbor of the current node:\n          <ol type=\"a\">\n            <li>Recursively call DFS on that neighbor. üîÑ</li>\n          </ol>\n        </li>\n      </ol>\n\n      <h4>Iterative Implementation (using a Stack):</h4>\n      <ol>\n        <li>Push the start node onto a <b>stack</b>. ‚ûï</li>\n        <li>While the stack is not empty:\n          <ol type=\"a\">\n            <li>Pop a node from the stack. ‚ûñ</li>\n            <li>If the node is not visited:\n              <ol type=\"i\">\n                <li>Mark the node as <b>visited</b>. ‚úÖ</li>\n                <li>Push all the <b>unvisited</b> neighbors of the node onto the stack. ‚ûï</li>\n              </ol>\n            </li>\n          </ol>\n        </li>\n      </ol>\n    </div>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>üîë Key Characteristics:</h3>\n      <ul>\n        <li>Goes deep down each branch before backtracking.</li>\n        <li>Uses a <b>stack</b> (implicitly with recursion, explicitly with iteration). ‚è≥</li>\n        <li>Suitable for detecting cycles in a graph. üîÑ</li>\n      </ul>\n    </div>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>üìù Pseudocode (Recursive):</h3>\n      <pre style=\"background-color: #f9f9f9; padding: 10px; border-radius: 5px;\">\n        <code>\nDFS(graph, node, visited):\n  visited.add(node)\n  process(node) // Visit the node\n\n  for neighbor in graph.neighbors(node):\n    if neighbor not in visited:\n      DFS(graph, neighbor, visited)\n        </code>\n      </pre>\n\n      <h3>üìù Pseudocode (Iterative):</h3>\n      <pre style=\"background-color: #f9f9f9; padding: 10px; border-radius: 5px;\">\n        <code>\nDFS(graph, startNode):\n  stack = new Stack()\n  visited = new Set()\n\n  stack.push(startNode)\n\n  while not stack.isEmpty():\n    node = stack.pop()\n\n    if node not in visited:\n      visited.add(node)\n      process(node) // Visit the node\n\n      for neighbor in graph.neighbors(node):\n        if neighbor not in visited:\n          stack.push(neighbor)\n        </code>\n      </pre>\n    </div>\n\n    <div style=\"margin-bottom: 15px;\">\n      <h3>‚è±Ô∏è Time Complexity:</h3>\n      <p><b>O(V + E)</b>, where V is the number of vertices (nodes) and E is the number of edges.</p>\n    </div>\n\n    <div>\n      <h3>‚ûï Applications:</h3>\n      <ul>\n        <li>Detecting cycles in a graph. üîÑ</li>\n        <li>Topological sorting. ‚¨ÜÔ∏è</li>\n        <li>Solving puzzles (like mazes). üß©</li>\n        <li>Finding connected components. üîó</li>\n      </ul>\n    </div>\n  </section>\n\n  <section style=\"padding: 20px; border: 1px solid #ddd; border-radius: 5px;\">\n    <h2>üÜö BFS vs DFS: A Quick Comparison</h2>\n\n    <table style=\"width: 100%; border-collapse: collapse;\">\n      <thead>\n        <tr style=\"background-color: #eee;\">\n          <th style=\"padding: 8px; border: 1px solid #ddd; text-align: left;\">Feature</th>\n          <th style=\"padding: 8px; border: 1px solid #ddd; text-align: left;\">BFS</th>\n          <th style=\"padding: 8px; border: 1px solid #ddd; text-align: left;\">DFS</th>\n        </tr>\n      </thead>\n      <tbody>\n        <tr>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Data Structure</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Queue</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Stack (or Recursion)</td>\n        </tr>\n        <tr>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Traversal Order</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Level-order</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Depth-first</td>\n        </tr>\n        <tr>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Shortest Path (Unweighted)</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Guaranteed to find</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">May not find</td>\n        </tr>\n        <tr>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Memory Usage</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Can be higher (stores all nodes at a level)</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Generally lower</td>\n        </tr>\n        <tr>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Applications</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Shortest path, web crawling</td>\n          <td style=\"padding: 8px; border: 1px solid #ddd;\">Cycle detection, topological sorting</td>\n        </tr>\n      </tbody>\n    </table>\n  </section>\n\n  <footer style=\"text-align: center; margin-top: 30px; color: #777;\">\n    <p>Happy traversing! üöÄ</p>\n  </footer>\n\n</div>\n\n<style>\n  .container {\n    width: 80%;\n    margin: 0 auto;\n    font-family: sans-serif;\n    line-height: 1.6;\n  }\n\n  h1, h2, h3 {\n    color: #333;\n  }\n\n  ul, ol {\n    margin-bottom: 15px;\n  }\n  pre {\n    overflow-x: auto; /* Enable horizontal scrolling for long code snippets */\n  }\n\n</style>\n```"},
      ],
    },
  ],
});


export const GenerateStudyTypeContentAiModel = model.startChat({
  generationConfig,
  history: [
    {
      role: "user",
      parts: [
        { text: "Generate the flashcard on topic: Flutter Fundamentals, User Interface (UI) Development, Basic App Navigation in JSON format with front back content, Maximum 15\n" },
      ],
    },
    {
      role: "model",
      parts: [
        { text: "```json\n[\n  {\n    \"front\": \"What is Flutter's UI building paradigm?\",\n    \"back\": \"Flutter uses a declarative UI paradigm. You describe the desired UI state, and Flutter handles the rendering and updates efficiently.\"\n  },\n  {\n    \"front\": \"What is a Widget in Flutter?\",\n    \"back\": \"A Widget is the basic building block of a Flutter UI. Everything is a Widget, from buttons and text to layouts and themes.\"\n  },\n  {\n    \"front\": \"Differentiate between Stateless and Stateful Widgets.\",\n    \"back\": \"StatelessWidgets are immutable (their properties can't change after creation), while StatefulWidgets can change their state, triggering UI updates.\"\n  },\n  {\n    \"front\": \"What is the purpose of the `build()` method in a Widget?\",\n    \"back\": \"The `build()` method describes the Widget's UI based on its current state (data) and should return another Widget tree.\"\n  },\n  {\n    \"front\": \"What is the significance of the `BuildContext`?\",\n    \"back\": \"The `BuildContext` provides access to the location of a widget within the widget tree, allowing interaction with the tree and access to theme data, media queries, and other inherited resources.\"\n  },\n  {\n    \"front\": \"Name a common layout widget in Flutter.\",\n    \"back\": \"Examples: `Column`, `Row`, `Stack`, `Container`.\"\n  },\n  {\n    \"front\": \"How do you add padding around a Widget?\",\n    \"back\": \"Use the `Padding` widget. Wrap the target widget with `Padding(padding: EdgeInsets.all(16.0), child: ...)` (adjust the `EdgeInsets` value).\"\n  },\n  {\n    \"front\": \"What's the purpose of the `MaterialApp` widget?\",\n    \"back\": \"The `MaterialApp` widget sets up the basic app structure, including the theme, title, routes, and home screen, following Material Design principles.\"\n  },\n  {\n    \"front\": \"How can you change the text style of a `Text` widget?\",\n    \"back\": \"Use the `style` property of the `Text` widget and assign a `TextStyle` object with the desired properties (e.g., `fontSize`, `fontWeight`, `color`).\"\n  },\n  {\n    \"front\": \"How do you navigate between different screens (Routes) in Flutter?\",\n    \"back\": \"Use the `Navigator` widget, typically using `Navigator.push()` to push a new route onto the stack and `Navigator.pop()` to return to the previous route.\"\n  },\n  {\n    \"front\": \"What is a `Route` in Flutter?\",\n    \"back\": \"A `Route` represents a screen or a page in your application.  Flutter's `Navigator` manages the routes in a stack.\"\n  },\n  {\n    \"front\": \"How do you define named routes in Flutter?\",\n    \"back\": \"In `MaterialApp`, use the `routes` property to map route names (strings) to widget builders (functions that return a widget).  Example: `routes: {'/home': (context) => HomePage()}`\"\n  },\n  {\n    \"front\": \"How do you pass data between routes?\",\n    \"back\": \"You can pass data as arguments to the route using the `arguments` parameter in `Navigator.pushNamed()` or directly as arguments in `Navigator.push()` with a custom route object.\"\n  },\n  {\n    \"front\": \"What is `Navigator.pushReplacementNamed()`?\",\n    \"back\": \"It replaces the current route in the navigator's stack with the named route, preventing the user from navigating back to the previous screen.\"\n  },\n  {\n    \"front\": \"What widget should you use to create a bottom navigation bar?\",\n    \"back\": \"Use the `BottomNavigationBar` widget in conjunction with a `Scaffold` widget.\"\n  }\n]\n```" },
      ],
    },
  ],
});

export const GenerateQuizAiModel = model.startChat({
  generationConfig,
  history: [
    {
      role: "user",
      parts: [
        {text: "Generate Quiz on topic: Introduction to Search Problems,Breadth-First Search (BFS),Depth-First Search (DFS),Depth-Limited Search and Iterative Deepening Depth-First Search (IDS),Uniform-Cost Search (UCS),Bidirectional Search,Comparative Analysis and Algorithm Selection with Question and Options with correct answer along with detailed explanation for the answer in JSON format, (Max 10)"},
      ],
    },
    {
      role: "model",
      parts: [
        {text: "```json\n[\n  {\n    \"question\": \"What is the primary goal in solving search problems?\",\n    \"options\": [\n      \"To find all possible paths to the goal state.\",\n      \"To find the most aesthetically pleasing path to the goal state.\",\n      \"To find the optimal or a satisfactory path from the initial state to the goal state.\",\n      \"To exhaustively explore the entire search space.\"\n    ],\n    \"answer\": \"To find the optimal or a satisfactory path from the initial state to the goal state.\",\n    \"explanation\": \"The main objective in search problems is to navigate from an initial state to a desired goal state by identifying a suitable path. This path can be optimal (best according to some criteria) or simply satisfactory (meeting a predefined set of requirements).\"\n  },\n  {\n    \"question\": \"Which search algorithm guarantees finding the shortest path to the goal in an unweighted graph?\",\n    \"options\": [\n      \"Depth-First Search (DFS)\",\n      \"Breadth-First Search (BFS)\",\n      \"Depth-Limited Search\",\n      \"Iterative Deepening Search (IDS)\"\n    ],\n    \"answer\": \"Breadth-First Search (BFS)\",\n    \"explanation\": \"BFS explores the graph layer by layer, ensuring that nodes closer to the root are visited before nodes farther away. In an unweighted graph, this guarantees that the first solution found is also the shortest path (in terms of the number of edges).\"\n  },\n  {\n    \"question\": \"Which of the following is a disadvantage of Depth-First Search (DFS)?\",\n    \"options\": [\n      \"It always finds the optimal solution.\",\n      \"It can get trapped in infinite loops or very deep branches.\",\n      \"It has low memory requirements.\",\n      \"It is suitable for finding the shortest path in an unweighted graph.\"\n    ],\n    \"answer\": \"It can get trapped in infinite loops or very deep branches.\",\n    \"explanation\": \"DFS explores deeply along each branch before backtracking.  If the graph contains cycles or very long, unproductive paths, DFS may not terminate or may explore a vast portion of the search space before finding a solution or determining that none exists. It's not guaranteed to find the optimal solution, nor is it ideal for shortest path problems in unweighted graphs, although it has relatively low memory requirements.\"\n  },\n  {\n    \"question\": \"What is the purpose of the depth limit in Depth-Limited Search?\",\n    \"options\": [\n      \"To ensure the algorithm finds the optimal solution.\",\n      \"To reduce the space complexity of the algorithm.\",\n      \"To prevent infinite loops by limiting the depth of exploration.\",\n      \"To increase the time complexity of the algorithm.\"\n    ],\n    \"answer\": \"To prevent infinite loops by limiting the depth of exploration.\",\n    \"explanation\": \"Depth-Limited Search introduces a maximum depth to which the algorithm will explore.  This is crucial to prevent DFS from getting stuck in infinite loops when exploring graphs with cycles or very deep branches. However, it doesn't guarantee finding an optimal solution, and it doesn't necessarily reduce space complexity compared to standard DFS.\"\n  },\n  {\n    \"question\": \"Which search algorithm combines the space efficiency of DFS with the completeness of BFS?\",\n    \"options\": [\n      \"Uniform-Cost Search (UCS)\",\n      \"Bidirectional Search\",\n      \"Iterative Deepening Depth-First Search (IDS)\",\n      \"Greedy Best-First Search\"\n    ],\n    \"answer\": \"Iterative Deepening Depth-First Search (IDS)\",\n    \"explanation\": \"IDS repeatedly performs depth-limited searches with increasing depth limits until a goal is found. This way, it explores the search space breadth-first, guaranteeing completeness (finding a solution if one exists) like BFS, while using the memory-efficient approach of DFS at each iteration.\"\n  },\n  {\n    \"question\": \"Which search algorithm expands nodes based on the cost from the start node to the current node?\",\n    \"options\": [\n      \"Depth-First Search (DFS)\",\n      \"Breadth-First Search (BFS)\",\n      \"Uniform-Cost Search (UCS)\",\n      \"A* Search\"\n    ],\n    \"answer\": \"Uniform-Cost Search (UCS)\",\n    \"explanation\": \"UCS expands nodes in order of their path cost from the starting node. It uses a priority queue to keep track of nodes to be explored, prioritizing nodes with lower costs. This ensures that the cheapest path to the goal is found (assuming that the cost is positive), making it an optimal algorithm for weighted graphs.\"\n  },\n  {\n    \"question\": \"What is the main advantage of Bidirectional Search?\",\n    \"options\": [\n      \"It always finds the optimal solution.\",\n      \"It reduces the space complexity compared to BFS.\",\n      \"It reduces the time complexity by searching from both the initial and goal states simultaneously.\",\n      \"It is easier to implement than other search algorithms.\"\n    ],\n    \"answer\": \"It reduces the time complexity by searching from both the initial and goal states simultaneously.\",\n    \"explanation\": \"Bidirectional search reduces the search space by running two searches simultaneously: one forward from the initial state and one backward from the goal state. The search terminates when the two frontiers meet. This can significantly reduce the time complexity, especially in cases where the branching factor is high.\"\n  },\n  {\n    \"question\": \"In what situation would you primarily choose Breadth-First Search (BFS) over Depth-First Search (DFS)?\",\n    \"options\": [\n      \"When the search space is very large and deep, and you are not concerned with finding the optimal solution.\",\n      \"When you know the goal state is likely to be found deep in the search tree.\",\n      \"When you need to find the shortest path in an unweighted graph.\",\n      \"When memory is severely limited.\"\n    ],\n    \"answer\": \"When you need to find the shortest path in an unweighted graph.\",\n    \"explanation\": \"BFS is the preferred choice when finding the shortest path in unweighted graphs.  DFS might find a solution faster in some cases, but it doesn't guarantee optimality. DFS is better suited for situations where memory is limited, or the goal is likely to be deep in the search tree, and optimality is not a primary concern.\"\n  },\n  {\n    \"question\": \"When should Uniform-Cost Search (UCS) be preferred over Breadth-First Search (BFS)?\",\n    \"options\": [\n      \"When all actions have the same cost.\",\n      \"When the goal state is known to be near the initial state.\",\n      \"When actions have varying costs.\",\n      \"When memory consumption is a critical constraint.\"\n    ],\n    \"answer\": \"When actions have varying costs.\",\n    \"explanation\": \"UCS is designed to handle situations where actions have different costs. BFS, on the other hand, implicitly assumes that all actions have the same cost (cost of 1). If costs vary, BFS will not necessarily find the optimal (least-cost) solution. If all costs are the same, BFS is often more efficient due to its simpler implementation.\"\n  },\n  {\n    \"question\": \"Which of the following is TRUE about Iterative Deepening Search?\",\n    \"options\": [\n      \"It is optimal if the branching factor is infinite.\",\n      \"It is more space efficient than BFS.\",\n      \"It is less time efficient than DFS\",\n      \"It requires more memory than BFS.\"\n    ],\n    \"answer\": \"It is more space efficient than BFS.\",\n    \"explanation\": \"Iterative Deepening Search performs multiple Depth-First Searches with increasing depth limits. This allows it to achieve the space efficiency of DFS, as it only needs to store the current path being explored at each iteration. BFS, on the other hand, stores all nodes at the current level, requiring significantly more memory.  While IDS repeats work, its time complexity is often acceptable, especially if the branching factor is not too large.\"\n  }\n]\n```"},
      ],
    },
  ],
});

export const GenerateQuestionsAiModel = model.startChat({
  generationConfig,
  history: [
    {
      role: "user",
      parts: [
        { text: "Generate a question bank containing questions and detailed answers on the topic \"Physics: Mechanical Properties of Fluids\" with the difficulty level set to \"hard\" in JSON format with a maximum of 10 questions." },
      ],
    },
    {
      role: "model",
      parts: [
        { text: "```json\n{\n  \"question_bank\": [\n    {\n      \"question_id\": \"fluid_mechanics_1\",\n      \"question\": \"A thin liquid film is held between two parallel circular plates, each of radius R, separated by a distance d, where d << R. A force F is applied to the upper plate. Derive an expression for the time taken to separate the plates to a distance 2d, assuming the liquid viscosity is Œ∑ and surface tension effects are negligible. Analyze the dependence of the separation time on the applied force, viscosity, radius, and initial separation.\",\n      \"answer\": \"This problem requires solving the Reynold's equation for squeeze film lubrication. The pressure distribution in the liquid film is given by ‚àÇ/‚àÇr (r (‚àÇp/‚àÇr)) = (6Œ∑v_z r)/h^3, where v_z is the vertical velocity of the plate and h is the instantaneous separation. \\n1.  **Relate Force and Pressure:**  F = ‚à´ p(r) 2œÄr dr (integral from 0 to R).\\n2.  **Solve Reynold's Equation:** Integrate the differential equation to find p(r) in terms of v_z, Œ∑, h, and r.  Apply the boundary condition p(R) = 0 (atmospheric pressure at the edge).\\n3.  **Express v_z:**  v_z = dh/dt (rate of change of separation).\\n4.  **Substitute and Integrate:** Substitute the expression for p(r) into the force equation and solve for dh/dt.  Integrate the resulting differential equation with respect to time, from h = d to h = 2d.  This will give the separation time 't'.\\n5.  **Result:** The separation time 't' is approximately t = (3œÄŒ∑R‚Å¥)/(2Fd¬≥).  Therefore, the separation time is directly proportional to the viscosity and the fourth power of the radius, and inversely proportional to the applied force and the cube of the initial separation. This shows that larger radius, higher viscosity or smaller force requires longer time to separate the plates.\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_2\",\n      \"question\": \"A spherical bubble of radius r1 is formed inside another bubble of radius r2 in vacuum. If the surface tension of the liquid film is T, determine the pressure difference (ŒîP) between the inside of the smaller bubble (r1) and the vacuum outside the larger bubble (r2). Then, calculate the pressure difference if instead of vacuum, both bubbles are inside a container filled with a gas with a constant pressure.\",\n      \"answer\": \"1. **Pressure Difference Across a Single Surface:** For a single spherical bubble, the pressure difference is ŒîP = 2T/r. However, for a soap bubble, which has two surfaces (inner and outer), the pressure difference is ŒîP = 4T/r.\\n2. **Pressure Inside r1:** The pressure inside the inner bubble (r1) is P1 = P_vacuum + 4T/r1 = 4T/r1 (since P_vacuum = 0).\\n3. **Pressure Inside r2:**  The pressure inside the outer bubble (r2) is P2. The pressure difference between r1 and r2 can be expressed as P1 = P2 + 4T/r2.  Therefore, P2 = P1 - 4T/r2 = 4T/r1 - 4T/r2.\\n4. **Pressure Difference:** The pressure difference between inside r1 and outside r2 (vacuum) is ŒîP = P1 - P_vacuum = P1 = 4T/r1.\\n5. **Both Bubbles inside a Container with Gas:** In this case, the external pressure is P_gas.  So, P1 = P_gas + 4T/r1, and P2 = P_gas + 4T/r2. Therefore, the pressure inside r1 is greater than inside r2 and the differential pressure between both bubbles is still 4T/r1-4T/r2. The total pressure of inside r1 would be P_gas + 4T/r1 and P_gas + 4T/r2 inside r2.\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_3\",\n      \"question\": \"A cylindrical container of radius R is filled with a liquid of density œÅ and viscosity Œ∑. The container is rotated about its vertical axis with a constant angular velocity œâ. Determine the shape of the free surface of the liquid and find the equation of the surface as a function of radial distance r from the axis of rotation. Also, explain how the viscosity affects this result.\",\n      \"answer\": \"1. **Equilibrium Condition:** At any point on the free surface, the net force (gravitational and centrifugal) must be perpendicular to the surface. This implies that tan Œ∏ = (œâ¬≤r)/g, where Œ∏ is the angle the surface makes with the horizontal, r is the radial distance from the axis, and g is the acceleration due to gravity.\\n2. **Relate tan Œ∏ to the Slope:**  tan Œ∏ = dy/dr, where y is the height of the liquid surface above a reference level.\\n3. **Differential Equation:**  dy/dr = (œâ¬≤r)/g\\n4. **Integrate:** Integrate the equation to find y(r):  ‚à´dy = ‚à´(œâ¬≤r/g)dr => y = (œâ¬≤r¬≤)/(2g) + C, where C is the constant of integration.\\n5. **Determine Constant of Integration:** Choose the origin to be at the center of the bottom of the container. The volume of the liquid must remain constant. If the initial height of the liquid was h, then the volume is œÄR¬≤h. The volume after rotation can be found by integrating the area of the surface across the radius. Setting those equal will determine C.\\n6. **Shape of the Surface:** The shape of the free surface is a paraboloid of revolution.  The equation of the surface is y = (œâ¬≤r¬≤)/(2g) + C.\\n7. **Effect of Viscosity:** Viscosity does *not* affect the final shape of the free surface in a steady-state condition. Viscosity only plays a role in how *quickly* the fluid reaches this equilibrium shape. If the rotation rate changes quickly, viscosity will provide resistance and the surface may not immediately conform to the parabolic shape. Once a steady state is reached, viscosity's influence vanishes.\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_4\",\n      \"question\": \"A soap bubble with internal gauge pressure P and radius R bursts isothermally into a larger volume. If the atmospheric pressure is P_atm, the initial surface tension is T, and the process occurs slowly, determine the final radius of the resulting single larger spherical droplet. Assume the air inside the bubble behaves like an ideal gas and surface tension effects are negligible in the final droplet. Is this a valid assumption?\",\n      \"answer\": \"1. **Initial Conditions:**  Initial pressure inside the bubble is P + P_atm = P_in = P_atm + 4T/R (Laplace's law for a soap bubble).\\n2. **Initial Volume:**  Initial volume of the air inside the bubble is V1 = (4/3)œÄR¬≥.\\n3. **Isothermal Expansion:** Since the process is isothermal, P_in * V1 = P_atm * V2, where V2 is the final volume of the air and the final pressure is assumed to be roughly atmospheric since gauge pressure is negligible.\\n4. **Final Volume:** Therefore, V2 = (P_in * V1) / P_atm = ((P_atm + 4T/R) * (4/3)œÄR¬≥) / P_atm.\\n5. **Final Radius:** Let R_f be the final radius of the droplet.  Then V2 = (4/3)œÄR_f¬≥.  Solving for R_f, we get R_f = [((P_atm + 4T/R) * R¬≥) / P_atm]^(1/3) = R * (1 + 4T/(P_atm * R))^(1/3).\\n6. **Validity of Neglecting Surface Tension in Final Droplet:** The assumption that surface tension is negligible in the final droplet is valid if 4T/R_f << P_atm.  In other words, if the contribution of the surface tension to the pressure inside the final droplet is much smaller than the atmospheric pressure, the assumption holds. This is more likely to be true if R_f is sufficiently large.\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_5\",\n      \"question\": \"A small air bubble of radius 'r' is rising steadily through a viscous liquid of density 'œÅ' and viscosity 'Œ∑'. The liquid is contained in a very large tank. Considering that the density of air is negligible compared to the density of the liquid, derive an expression for the terminal velocity 'v' of the air bubble. Then, discuss how the shape of the bubble will affect the drag and velocity for larger bubbles.\",\n      \"answer\": \"1. **Forces Acting on the Bubble:** The forces acting on the bubble are:  Buoyant force (Fb) upward, Viscous drag force (Fd) downward, and Weight (Fg) which is negligible since the density of the air is assumed to be close to 0.\\n2. **Buoyant Force:** Fb = (4/3)œÄr¬≥œÅg, where 'œÅ' is the density of the liquid and 'g' is the acceleration due to gravity.\\n3. **Stokes' Law for Viscous Drag:** For a small sphere moving slowly through a viscous fluid, the drag force is given by Stokes' Law: Fd = 6œÄŒ∑rv.\\n4. **Terminal Velocity:** At terminal velocity, the net force is zero. Thus, Fb - Fd = 0, which implies (4/3)œÄr¬≥œÅg = 6œÄŒ∑rv.\\n5. **Solve for v:** Solving for the terminal velocity 'v', we get v = (2œÅgr¬≤)/(9Œ∑).\\n6. **Shape Effects on Larger Bubbles:** As the bubble size increases, the assumption of a spherical shape breaks down. Larger bubbles become distorted and take on a more ellipsoidal or irregular shape. This leads to deviations from Stokes' Law.\\n7. **Increased Drag:** The drag coefficient for non-spherical shapes is higher than that predicted by Stokes' Law. The drag force becomes dependent on the shape and orientation of the bubble. This happens because as the bubble becomes bigger, the liquid cannot flow smoothly around it and creates turbulence.\\n8. **Modified Velocity:**  Due to the increased drag, the terminal velocity of larger, non-spherical bubbles is lower than what would be predicted by the Stokes' Law formula using the initial radius.  More complex drag force models, considering the shape and flow regime, are needed to accurately predict the terminal velocity of large bubbles.\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_6\",\n      \"question\": \"Consider a liquid flowing through a horizontal pipe with a varying cross-sectional area. Derive an expression for the pressure difference between two points in the pipe in terms of the flow rate, the densities and areas at the two points. How does the viscosity of the fluid impact the pressure difference in a real-world scenario?\",\n      \"answer\": \"1. **Assumptions:** In a real-world problem, we need to consider the viscosity of the fluid and understand that the flow is not ideal. We will need to assume that the liquid is incompressible and that flow is steady.\\n2. **Continuity Equation:** For an incompressible fluid, the volume flow rate (Q) is constant. Therefore, A1v1 = A2v2 = Q, where A1 and A2 are the cross-sectional areas at points 1 and 2, and v1 and v2 are the velocities at those points.\\n3. **Bernoulli's Equation:** Apply Bernoulli's equation between points 1 and 2: P1 + (1/2)œÅv1¬≤ + œÅgh1 = P2 + (1/2)œÅv2¬≤ + œÅgh2. Since the pipe is horizontal, h1 = h2, so the gravitational potential energy terms cancel out.\\n4. **Solve for Pressure Difference:** P1 - P2 = (1/2)œÅ(v2¬≤ - v1¬≤).  Substitute v1 = Q/A1 and v2 = Q/A2 into the equation.\\n5. **Pressure Difference Expression:** P1 - P2 = (1/2)œÅQ¬≤(1/A2¬≤ - 1/A1¬≤).\\n6. **Impact of Viscosity:** In a real-world scenario, viscosity will introduce frictional losses within the fluid. These losses will dissipate energy, causing a pressure drop along the pipe *in addition* to the pressure difference calculated above from Bernoulli's principle. The viscous pressure drop is typically modeled using the Darcy-Weisbach equation, which involves the friction factor, pipe length, diameter, and fluid velocity. Therefore, the actual pressure difference will be greater than the one calculated using only Bernoulli's equation, as the calculation above has not considered this loss in pressure due to viscosity. To incorporate the viscosity in this case, a more complex model considering pressure loss due to frictional forces along the horizontal pipe is necessary.\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_7\",\n      \"question\": \"A liquid with surface tension T is placed between two parallel glass plates separated by a small distance 'd'. Derive an expression for the force per unit length required to separate the plates. How would the presence of dust particles at the interface affect this separating force?\",\n      \"answer\": \"1. **Origin of the Force:** The liquid forms a curved meniscus between the plates due to surface tension. This meniscus creates a negative pressure (lower than atmospheric) within the liquid film.\\n2. **Laplace Pressure:** The pressure difference (ŒîP) across the curved liquid-air interface is given by the Laplace pressure: ŒîP = T(1/R1 + 1/R2), where R1 and R2 are the principal radii of curvature.\\n3. **Geometry of the Meniscus:** Since the plates are very close, one radius of curvature (R1) is essentially infinite (the curvature along the plate). The other radius of curvature (R2) is approximately d/2 (half the separation distance).  So, ŒîP = T/(d/2) = 2T/d.\\n4. **Force per Unit Length:** The force per unit length (F/L) required to separate the plates is equal to the pressure difference multiplied by the separation distance: F/L = ŒîP * d = (2T/d) * d = 2T.\\n5. **Effect of Dust Particles:** The presence of dust particles at the interface *increases* the force required to separate the plates. Dust particles disrupt the continuous liquid film, creating multiple smaller menisci. Each of these menisci contributes to the negative pressure within the liquid. Also, dust particles can increase the contact area between liquid and the plate, leading to increased adhesion. The overall effect is an increase in the effective surface tension and a corresponding increase in the force per unit length needed for separation.\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_8\",\n      \"question\": \"Derive an expression for the capillary rise (h) of a liquid of density œÅ and surface tension T inside a capillary tube of radius r, assuming a contact angle Œ∏ between the liquid and the tube wall. How will a change in temperature impact the capillary rise, assuming all other parameters remain constant?\",\n      \"answer\": \"1. **Forces Involved:** The forces involved are: Weight of the liquid column (Fg) acting downwards and Surface tension force (Fs) acting upwards.\\n2. **Surface Tension Force:** The surface tension force acts along the circumference of the contact line between the liquid and the tube.  Fs = T * (2œÄr) * cos Œ∏, where Œ∏ is the contact angle.\\n3. **Weight of the Liquid Column:** The weight of the liquid column is Fg = (œÄr¬≤h) * œÅg, where 'h' is the height of the liquid column, 'œÅ' is the density of the liquid, and 'g' is the acceleration due to gravity.\\n4. **Equilibrium Condition:** At equilibrium, the upward force due to surface tension balances the downward force due to the weight of the liquid column: Fs = Fg.\\n5. **Solve for Capillary Rise:**  T * (2œÄr) * cos Œ∏ = (œÄr¬≤h) * œÅg.  Solving for h, we get h = (2T cos Œ∏) / (œÅgr).\\n6. **Effect of Temperature Change:**  An increase in temperature typically *decreases* both the surface tension (T) and the density (œÅ) of the liquid. Also, it usually reduces the contact angle Œ∏. The exact relationship depends on the specific liquid and the capillary tube material. In most liquids, the reduction in surface tension dominates and, therefore, a higher temperature typically *decreases* the capillary rise (h). Although density also decreases with temperature, that change is usually much less significant than surface tension change. The changes in contact angle can be harder to predict.\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_9\",\n      \"question\": \"A spherical ball of radius R and density œÅ is dropped into a viscous liquid of density œÅ_l and viscosity Œ∑. Assuming œÅ > œÅ_l, derive a differential equation for the velocity v(t) of the ball as a function of time, taking into account the buoyant force, viscous drag (Stokes' Law), and the gravitational force. Then, using this differential equation, solve for the general solution for v(t).\",\n      \"answer\": \"1. **Forces Acting on the Ball:** Gravitational force (Fg) downward, Buoyant force (Fb) upward, and Viscous drag force (Fd) upward.\\n2. **Gravitational Force:** Fg = (4/3)œÄR¬≥œÅg\\n3. **Buoyant Force:** Fb = (4/3)œÄR¬≥œÅ_l g\\n4. **Stokes' Law:** Fd = 6œÄŒ∑Rv\\n5. **Net Force and Newton's Second Law:** The net force on the ball is F_net = Fg - Fb - Fd.  According to Newton's Second Law, F_net = ma = (4/3)œÄR¬≥œÅ(dv/dt).\\n6. **Differential Equation:** Substituting the expressions for the forces, we get (4/3)œÄR¬≥œÅ(dv/dt) = (4/3)œÄR¬≥œÅg - (4/3)œÄR¬≥œÅ_l g - 6œÄŒ∑Rv.  Simplifying, dv/dt = g(1 - œÅ_l/œÅ) - (9Œ∑v)/(2R¬≤œÅ).\\n7. **Solving the Differential Equation:** This is a first-order linear ordinary differential equation of the form dv/dt + Pv = Q, where P = (9Œ∑)/(2R¬≤œÅ) and Q = g(1 - œÅ_l/œÅ).\\n8. **Integrating Factor:** The integrating factor is e^(‚à´P dt) = e^(Pt) = e^((9Œ∑t)/(2R¬≤œÅ)).\\n9. **General Solution:** Multiplying the differential equation by the integrating factor and integrating, we get: v(t)e^(Pt) = ‚à´Qe^(Pt) dt = (Q/P)e^(Pt) + C, where C is the constant of integration.\\n10. **Final Solution:** Solving for v(t), we obtain v(t) = (Q/P) + Ce^(-Pt) = (2gR¬≤œÅ(1 - œÅ_l/œÅ))/(9Œ∑) + Ce^(-(9Œ∑t)/(2R¬≤œÅ)).  This is the general solution for the velocity of the ball as a function of time. The constant C can be found from the initial conditions (e.g., if the ball starts from rest, v(0) = 0).\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    },\n    {\n      \"question_id\": \"fluid_mechanics_10\",\n      \"question\": \"A U-tube is filled with a liquid of density œÅ. The length of the liquid column in one arm of the U-tube is L. If the liquid is initially displaced slightly from equilibrium and then released, show that the resulting oscillations of the liquid column are simple harmonic. Then, determine the frequency of oscillation.\",\n      \"answer\": \"1. **Displacement from Equilibrium:** Let x be the displacement of the liquid surface from its equilibrium position in one arm of the U-tube. The liquid level in the other arm will then be displaced by the same amount but in the opposite direction.\\n2. **Restoring Force:** The difference in height between the liquid levels in the two arms is 2x. This height difference creates a pressure difference ŒîP = 2œÅgx. The force on the liquid column due to this pressure difference is F = ŒîP * A = 2œÅgxA, where A is the cross-sectional area of the U-tube.\\n3. **Mass of the Liquid Column:** The total mass of the liquid oscillating is m = œÅAL, where L is the total length of the liquid column in the U-tube.\\n4. **Newton's Second Law:** Applying Newton's Second Law, F = ma, where a is the acceleration of the liquid column: 2œÅgxA = œÅAL(d¬≤x/dt¬≤).\\n5. **Differential Equation:** Simplifying, we get d¬≤x/dt¬≤ + (2g/L)x = 0. This is the differential equation for simple harmonic motion.\\n6. **Simple Harmonic Motion:** The equation d¬≤x/dt¬≤ + œâ¬≤x = 0 represents simple harmonic motion with angular frequency œâ, where œâ¬≤ = 2g/L. Therefore, the liquid oscillations are simple harmonic.\\n7. **Frequency of Oscillation:** The frequency of oscillation (f) is related to the angular frequency by f = œâ/(2œÄ). Therefore, f = (1/(2œÄ)) * ‚àö(2g/L).\",\n      \"difficulty\": \"hard\",\n      \"topic\": \"Mechanical Properties of Fluids\"\n    }\n  ]\n}\n```" },
      ],
    },
  ],
});